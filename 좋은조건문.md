# blog

simplify_if.js = 효율적인 if 에 대한 고민

제목 : 좋은 if 문 작성하기

왜 좋은 조건문(IF) 을 작성해야할까?

조건문은 모든 프로그래밍 언어를 막론하고 절대 빼놓을 수 없는 간단하지만 매우 중요한 뼈.대.요소라고 생각한다. 단순히 A의 조건에는 B의 로직이 수행되고, A가 아닌 조건에는 C의 로직이 수행된다는 개념을 떠나
새로운 조건이 계속 계속 생겨나면 그 조건 전체가 서비스의 복잡도를 결정할 만큼 중요한 요소라고 생각한다.

```js
if (A) {
    B();
} else {
    C();
}
```

좋은 조건문은 이러한 요소를 좋게 만든다는 것을 말한다.

그렇다면 좋은 조건문은 어떤 조건문을 말할까? 결국엔, 유지보수를 목적으로 하는 가.독.성 높은 조건문을 말한다. 여기서 단순히 가독성 높음에 집중하면 보기에만 좋은 떡?이 될 가능성이 높다. 유지보수를 목적으로
하는 가독성 높은 조건문을 작성한다면, 맛도 좋고 보기에도 좋은 떡?이 될 수 있다.

'유지보수를 목적으로 하는 가독성 높음' 이라는 말 자체는 어렵지만, 결국 서비스를 함께 만드는 개발 팀원끼리 서로의 조건 로직을 잘 이해해서 잘 디벨롭하는 것이라고 생각한다.

왜 좋은 조건문(IF) 을 작성해야할까? 라는 질문에 나는
'개발 팀원끼리 서로의 조건 로직을 잘 이해해 잘 디벨롭하기 위해서'라고 답하고 싶다.

여기에서 제시하는 몇가지 방법들은 대부분 사람들이 이해하기 쉬운 방법이라 제시해본다.

혼자 좋다고 주장하는 방법은 독이 될 수 있으니 이 글을 통해 여러가지 방법을 만나보고, 좋은 조건문을 만들기 위해 개발 팀원들과 충분히 고민해보는 계기가 되면 좋겠다.

=======================================

방법1. EARLY RETURN, EARLY EXIT

말대로 일찍이 RETURN 하고, 함수를 빠져나오는 것이다. 바로 코드를 보자.

```js
function isNumber(v) {
    return /^(\s|\d)+$/.test(v);
}

//<Base Code>
function getBoardByRegisterId(registerId) {
    if (registerId.length >= 4) {
        if (isNumber(registerId)) {
            const data = [];
            // 20 Line ...
            return data;
        } else {
            alert('아이디는 숫자만 유효합니다.');
        }
    } else {
        alert('아이디는 4자 이상 필요합니다.');
    }
}

//<Early Return - is Good?
function getBoardByRegisterId(registerId) {
    if (registerId.length < 4) return alert('아이디는 4자 이상 필요합니다.');
    if (!isNumber(registerId)) return alert('아이디는 숫자만 유효합니다.');
    const data = [];
    /**
     * 블라블라블라
     * 20 Line ...
     * 블라블라블라
     */
    return data;
}

```

조건문을 막연히 쓰다보면 위의 BAD 코드처럼 조건문(if) 마다 들여쓰기(indent)가 좌우로 늘어나고, 줄(line) 수도 상하로 늘어나게 된다. 상하좌우 모두 늘어나게 되면 한 눈에 읽어야하는 코드가 더
많아지기에 당연히 가독성은 떨어진다.

위와 같이 주 로직과 서브 로직(예. 자잘한 유효성 로직 등)을 함께 가지는 조건문을 쉽게 만날 수 있는데 주요 로직 부분의 라인 수가 길어지면 서브 로직 부분이 매우 하단에 위치하게 되어 읽기 어려워진다.

주요 로직을 큰 줄기로 두고 서브 로직을 곁가지로 두면 훨씬 이해하기 쉽다. [그림]

어떤 이들은 취향 차이라고 말하는 분들도 있지만, 좋은 코딩을 논할때 항상 나오는 키워드이자, 실제로 '우아한테크코스' 미션 중 'switch/case 와 else 예약어를 쓰지 않고 코드를 작성한다.' 라는 제한
조건으로
<Early Return> 방법을 권장하는 만큼 긍정적으로 보는 방법 중 하나로 보인다.

하지만 조건문이 보일때마다 <Early Return>을 적용하는 것이 맞을까?

좀 더 복잡한 코드를 보자.

```js
//<Base Code>
function executeUserLogic(paymentType, age, country) {
    let logicName = "";
    if (paymentType === "PAID") {
        if (age > 20) {
            if (country === "korean") {
                /**
                 * 블라블라블라
                 * 20 Line ...
                 * 블라블라블라
                 */
                logic1();
            } else {
                /**
                 * 블라블라블라
                 * 20 Line ...
                 * 블라블라블라
                 */
                logic2();
            }
        } else {
            /**
             * 블라블라블라
             * 20 Line ...
             * 블라블라블라
             */
            logic3();
        }
    } else {
        //pass
    }
}

//<Early Return - is Good?>
function executeUserLogic(alphabet, number, korean) {
    if (alphabet !== "PAID") return;
    if (number <= 20) {
        /**
         * 블라블라블라
         * 20 Line ...
         * 블라블라블라
         */
        logic3();
        return;
    }
    if (korean !== "korean") {
        /**
         * 블라블라블라
         * 20 Line ...
         * 블라블라블라
         */
        logic2();
        return;
    }
    /**
     * 블라블라블라
     * 20 Line ...
     * 블라블라블라
     */
    logic1();
}
```

각 로직의 영역마다 20줄(Line)을 차지한다면 이 함수 자체는 굉장히 거대한 함수일 가능성이 높다. 
또한, 3개의 인풋 변수에 의한 다양한 케이스를 다루면서 로직 하나하나 중요도가 높다면 매우 복잡해보일 수도 있다.  
그 거대하고 복잡한 함수를 <Early Return>을 통해 개선했다고 쳐도 결국 이해하기 어려운 건 매 한가지일 수도 있다.

명시적이지 않다고 느낄 수 있는 지점도 있는데, 
실제로 위 함수에서 Logic1 함수는 ['유료' and '성인' and '한국' 유저]들에게 실행시키고 싶은 것인데, 
<Early Return> 방법으로 개선되면 어떠한 조건들로 인하여 Logic1 함수가 실행되는지 위의 조건을 잘 훑어봐야한다.
이럴땐 <Early Return>이 최선이 아닐 수 있고 다른 방법을 시도하거나 다른 방법과 함께 <Early Return>을 시도해야한다.

이 지점부터는 <Early Return>이 사람마다 취향차이 일수도 있다는 생각이 확 들지만,
그럼에도 불구하고 나 같은 경우에는 <Early Return>은 무조건 적용해보고 또 다른 방법을 더해볼 것 같다. 

위 케이스를 좀 더 좋게 만들기 위해서는 다른 방법들을 좀 더 살펴본 뒤 해결해보면 좋을 것 같다.


(물론, 나 같은 경우에는 이)


상하좌우 보다 간결해졌다. 본능적으로 가독성이 높아졌음을 알 수 있다.

(하지만 조건이 복잡하다면 EALRY RETURN 이 무조건 옳다고 보긴 힘들다.)

경우의 수가 한 가지 늘어

좋은 분기문을 작성해야하는 이유

목적1 : 가독성을 높혀 로직을 쉽게 이해하기 위하여?

코드 작성 시 if, for문 등에서 들여쓰기(indent)를 쓰게 된다. 들여쓰기가 많아질수록 가독성과 유지보수의 용이함을 저해하는 경우가 생긴다.

목적2 :

1. 가독성
2.

1. EARLY RETURN, FAST EXIT

4. SWITCH 분기

2. && 와 || 적절히 활용하기 (short circuit)

3. 삼항연산자

3. JSON 분기

5. MAP 분기 (2개 컨디션)
   => 함수로 해결하는게 낫다.

6. 함수 분기

3. 하지만 분기가 많은게 나을때도 있다.